name: Weekly Account Validation

on:
  schedule:
    # Run every Sunday at 0:00 AM UTC
    - cron: '0 0 * * 0'
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: read
  issues: write

jobs:
  validate-accounts:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get all accounts
        id: get-accounts
        run: |
          set -euo pipefail
          echo "Getting all accounts from the data endpoint..." >&2

          # Function to retry curl commands with exponential backoff
          retry_curl() {
            local url="$1"
            local max_attempts=3
            local attempt=1
            local delay=5

            while [ $attempt -le $max_attempts ]; do
              echo "Attempt $attempt of $max_attempts for: $url" >&2

              # Check for HTTP 500 first (before using -f flag)
              local status_check
              status_check=$(curl -sS -o /dev/null -w '%{http_code}' "$url" 2>/dev/null || echo "000")
              if [ "$status_check" -ge 500 ] && [ "$status_check" -lt 600 ]; then
                echo "HTTP $status_check error detected. Backing off for 70 minutes..." >&2
                sleep 4200  # 70 minutes = 4200 seconds
                continue  # Retry without incrementing attempt counter
              fi

              # Use -f to make curl fail on HTTP errors; -S for error messages
              if response=$(curl -sSf "$url"); then
                echo "Success on attempt $attempt" >&2
                printf '%s' "$response"
                return 0
              else
                exit_code=$?
                echo "Curl failed with exit code $exit_code on attempt $attempt" >&2

                if [ $exit_code -eq 35 ] && [ $attempt -lt $max_attempts ]; then
                  echo "SSL/TLS error (exit code 35) detected. Retrying in ${delay} seconds..." >&2
                  sleep $delay
                  delay=$((delay * 2))  # Exponential backoff
                  attempt=$((attempt + 1))
                else
                  echo "Giving up after $attempt attempts or non-retriable error" >&2
                  return $exit_code
                fi
              fi
            done
          }

          # Retrieve raw JSON (only JSON will be printed to stdout by retry_curl)
          RAW_JSON=$(retry_curl "https://verifiedbsky.net/admin/data/${{ secrets.BSKY_PASSWORD }}")

          # Basic validation of JSON to fail early with a helpful message
            if ! echo "$RAW_JSON" | jq empty >/dev/null 2>&1; then
              echo "ERROR: Endpoint did not return valid JSON. Raw response:" >&2
              echo "----- BEGIN RESPONSE -----" >&2
              echo "$RAW_JSON" >&2
              echo "----- END RESPONSE -----" >&2
              exit 1
            fi

          # Extract account values (property name assumed to be Value as in original code)
          ACCOUNTS=$(echo "$RAW_JSON" | jq -r '.[].Value' | tr '\n' ' ')
          echo "Found accounts: $ACCOUNTS" >&2

          # Export for later steps
          {
            echo "accounts<<EOF"
            echo "$ACCOUNTS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Validate each account
        id: validate-accounts
        run: |
          set -euo pipefail
          echo "Starting validation of all accounts..." >&2

          # Hardened retry function (stdout = pure response body JSON)
          retry_curl() {
            local url="$1"; shift || true
            local method="GET"
            local data=""
            local header_opts=()
            while [ $# -gt 0 ]; do
              case "$1" in
                -X) method="$2"; shift 2 ;;
                -H) header_opts+=("-H" "$2"); shift 2 ;;
                -d) data="$2"; shift 2 ;;
                *) echo "Unknown arg to retry_curl: $1" >&2; return 2 ;;
              esac
            done

            local max_attempts=3 attempt=1 delay=5
            while [ $attempt -le $max_attempts ]; do
              echo "[retry_curl] Attempt $attempt/$max_attempts $method $url" >&2
              
              # Check for HTTP 500 first (before using -f flag)
              local status_check
              status_check=$(curl -sS -o /dev/null -w '%{http_code}' -X "$method" "${header_opts[@]}" ${data:+-d "$data"} "$url" 2>/dev/null || echo "000")
              if [ "$status_check" -ge 500 ] && [ "$status_check" -lt 600 ]; then
                echo "[retry_curl] HTTP $status_check error detected. Backing off for 70 minutes..." >&2
                sleep 4200  # 70 minutes = 4200 seconds
                continue  # Retry without incrementing attempt counter
              fi

              if response=$(curl -sSf -X "$method" "${header_opts[@]}" ${data:+-d "$data"} "$url"); then
                printf '%s' "$response"
                return 0
              else
                exit_code=$?
                echo "[retry_curl] curl exit $exit_code" >&2
                if [ $exit_code -eq 35 ] && [ $attempt -lt $max_attempts ]; then
                  echo "[retry_curl] TLS error; backing off ${delay}s" >&2
                  sleep $delay
                  delay=$((delay * 2))
                  attempt=$((attempt + 1))
                else
                  echo "[retry_curl] Giving up" >&2
                  return $exit_code
                fi
              fi
            done
          }

          post_json() {
            local handle="$1" module_key="$2" failure_count="$3"
            retry_curl "https://verifiedbsky.net/weekly-validation/${{ secrets.BSKY_PASSWORD }}" \
              -X POST \
              -H "Content-Type: application/json" \
              -d "{\"bskyHandle\":\"$handle\",\"moduleKey\":\"$module_key\",\"failureCount\":$failure_count}" || true
          }

          temp_file="/tmp/failed_accounts.json"
          echo '[]' > "$temp_file"

          raw_accounts='${{ steps.get-accounts.outputs.accounts }}'
          if [ -z "${raw_accounts// /}" ]; then
            echo "No accounts provided by previous step; exiting early." >&2
            echo 'failed-accounts=[]' >> "$GITHUB_OUTPUT"
            exit 0
          fi

            accounts=$(echo "$raw_accounts" | tr ' ' '\n' | grep -v '^$' | sort -u)

          for handle in $accounts; do
            echo "--- Validating $handle ---" >&2
            # Fetch validation JSON for the account
            validation_response=$(retry_curl "https://verifiedbsky.net/weekly-validation/$handle/${{ secrets.BSKY_PASSWORD }}" || true)

            if ! echo "$validation_response" | jq empty >/dev/null 2>&1; then
              echo "WARNING: Skipping $handle due to invalid JSON response" >&2
              echo "Response snippet:" >&2
              echo "$validation_response" | head -c 300 >&2 || true
              continue
            fi

            # If there are no moduleResults, skip gracefully
            module_count=$(echo "$validation_response" | jq '(.moduleResults // {}) | length')
            if [ "$module_count" -eq 0 ]; then
              echo "No moduleResults for $handle; skipping." >&2
              continue
            fi

            echo "$validation_response" | jq -r '.moduleResults | to_entries[] | @base64' | while IFS= read -r module_data; do
              [ -z "$module_data" ] && continue
              module_json=$(echo "$module_data" | base64 --decode)
              module_key=$(echo "$module_json" | jq -r '.key')
              is_valid=$(echo "$module_json" | jq -r '.value.isValid')
              current_failure_count=$(echo "$module_json" | jq -r '.value.failureCount')
              current_failure_count=${current_failure_count:-0}
              echo "Account $handle | Module $module_key | isValid=$is_valid | failureCount=$current_failure_count" >&2

              if [ "$is_valid" = "true" ]; then
                echo "Resetting failure count for $handle/$module_key" >&2
                post_json "$handle" "$module_key" 0 > /dev/null 2>&1 || true
              else
                new_failure_count=$((current_failure_count + 1))
                echo "Incrementing failure count to $new_failure_count for $handle/$module_key" >&2
                update_resp=$(post_json "$handle" "$module_key" "$new_failure_count" || true)
                # Validate update response JSON (optional)
                if echo "$update_resp" | jq empty >/dev/null 2>&1; then
                  message_sent=$(echo "$update_resp" | jq -r '.moduleResults[].messageSent // false')
                  message_success=$(echo "$update_resp" | jq -r '.moduleResults[].messageSuccess // false')
                  action=$(echo "$update_resp" | jq -r '.action // ""')
                else
                  message_sent=false
                  message_success=false
                  action=""
                fi

                # Append / merge failure info
                jq --arg handle "$handle" --arg module "$module_key" \
                   --argjson count "$new_failure_count" \
                   --argjson msg_sent "$message_sent" \
                   --argjson msg_success "$message_success" '
                  if any(.account == $handle) then
                    map(if .account == $handle then .modules += [{"module": $module, "failureCount": $count, "messageSent": $msg_sent, "messageSuccess": $msg_success}] else . end)
                  else
                    . + [{"account": $handle, "modules": [{"module": $module, "failureCount": $count, "messageSent": $msg_sent, "messageSuccess": $msg_success}]}]
                  end' "$temp_file" > "${temp_file}.tmp" && mv "${temp_file}.tmp" "$temp_file"

                if [ "$action" = "partial_removal" ]; then
                  echo "âš ï¸  $handle removed from $module_key due to max consecutive failures" >&2
                fi
              fi
              sleep 2
            done
            sleep 5
          done

          failures_json=$(cat "$temp_file")
          echo "Failed accounts data (JSON length: ${#failures_json} chars)" >&2
          {
            echo "failed-accounts<<EOF"
            echo "$failures_json"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          echo "Weekly validation completed!" >&2

      - name: Create issue for failed accounts
        if: steps.validate-accounts.outputs.failed-accounts != '[]' && steps.validate-accounts.outputs.failed-accounts != ''
        uses: actions/github-script@v7
        env:
          FAILED_ACCOUNTS_JSON: ${{ steps.validate-accounts.outputs.failed-accounts }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const failedAccounts = JSON.parse(process.env.FAILED_ACCOUNTS_JSON);
            
            if (failedAccounts.length === 0) {
              console.log('No failed accounts to report');
              return;
            }
            
            // Create the issue title and body
            const currentDate = new Date().toISOString().split('T')[0];
            const title = `Weekly Validation Failures - ${currentDate}`;
            
            let body = `# Weekly Account Validation Failures\n\n`;
            body += `**Date:** ${currentDate}\n\n`;
            body += `The following accounts failed validation during the weekly check:\n\n`;
            
            let totalFailures = 0;
            let notificationsSent = 0;
            let notificationsSuccessful = 0;
            
            body += `| Account | Module | Failure Count | Message Sent | Message Success |\n`;
            body += `|---------|--------|---------------|--------------|----------------|\n`;
            
            failedAccounts.forEach(account => {
              account.modules.forEach(module => {
                const msgSent = module.messageSent ? 'âœ…' : 'âŒ';
                const msgSuccess = module.messageSuccess ? 'âœ…' : 'âŒ';
                body += `| [${account.account}](https://bsky.app/profile/${account.account}) | ${module.module} | ${module.failureCount} | ${msgSent} | ${msgSuccess} |\n`;
                totalFailures++;
                if (module.messageSent) notificationsSent++;
                if (module.messageSuccess) notificationsSuccessful++;
              });
            });
            
            body += `\n`;
            
            body += `## Summary\n\n`;
            body += `- **Total accounts with failures:** ${failedAccounts.length}\n`;
            body += `- **Total module failures:** ${totalFailures}\n`;
            body += `- **Direct messages sent:** ${notificationsSent}\n`;
            body += `- **Successful messages:** ${notificationsSuccessful}\n\n`;
            body += `### Automated Actions\n\n`;
            body += `- âœ… Failure counts have been automatically incremented\n`;
            body += `- ðŸ“© Warning direct messages sent to users on their repeated failure\n`;
            body += `- ðŸš« Removal direct messages sent to users removed after max failure\n`;
            body += `- ðŸ”„ This issue was created automatically by the weekly validation workflow\n`;
            body += `- ðŸ“Š Check the [workflow run](${context.payload.repository.html_url}/actions/runs/${context.runId}) for detailed logs\n`;
            
            // Check if there's already an open issue for this week
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['weekly-validation', 'automated'],
              per_page: 10
            });
            
            const thisWeekIssue = existingIssues.data.find(issue => 
              issue.title.includes(currentDate)
            );
            
            if (thisWeekIssue) {
              // Update existing issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: thisWeekIssue.number,
                title: title,
                body: body
              });
              
              console.log(`Updated existing issue #${thisWeekIssue.number}`);
            } else {
              // Create new issue
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['weekly-validation', 'automated', 'bug']
              });
              
              console.log(`Created new issue #${issue.data.number}`);
            }

      - name: Summary
        run: |
          echo "## Weekly Validation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The weekly validation process has completed. Check the logs above for detailed results." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Process:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Retrieved all verified accounts from the data store" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” Validated each account using their original verification method for each module" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“Š Updated failure counts based on validation results per module" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš« Removed accounts from specific modules that failed validation for the maximum number of consecutive times (MaxFailureCount)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ Implemented automatic retry logic (up to 3 attempts) for network requests to handle SSL/TLS errors (exit code 35)" >> $GITHUB_STEP_SUMMARY
